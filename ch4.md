---
title: Java语言算法设计基础
---


#什么是程序？
有一个著名的公式说:

>==__程序=数据结构+算法__==

##什么是数据结构？

- 简单的数据结构就是众所周知的整型、实型这样的数据表示，
- 复杂的数据结构可以是由简单的数据结构组合而成，如数组。

##什么是算法？

算法就是用什么样的==方法==处理给定的数据从而得到所需的结果。

__例如__：

圆面积的计算公式为：
$$area = \pi \times r^2$$

其计算过程如下所示：

~~~java
// 程序:一个计算圆面积的程序
public class ComputeArea {
	public static void main(String[] args) {
		int r = 10;

		double area=3.14*r*r;

		System.out.println(area);
	}
}
~~~

---

#算法设计基础


##求解素数 

###什么是素数

- 素数是这样的整数，它除了能表示为它自己和1的乘积以外，不能表示为任何其它两个整数的乘积。
- 例如：$2$，$3$，$5$，$7$，$11$等。

###求解素数算法 
验证一个正整数$n$($n>3$)是否为素数，一个最直观的方法是看在$2$～$n/2$中能否找到一个整数$m$能将$n$整除。

- 若$m$存在，则$n$不是素数；
- 若找不到$m$，则$n$为素数。

这是一个循环验证算法，用下列表达式控制：

>初值：m=2；<br>
>循环条件：m<=n/2；<br>
>修正：m++；

注：它的作用是穷举$2$～$n/2$中的各$m$值。
循环体是判断$n$是否可以被$m$整除。

程序：求解100以内的全部素数

~~~java
public class PrimeApp {
	public static void main(String[] args) {
		int m, n;// 变量n为要判断的数字
		System.out.println("100以内的素数有：");
		A: for (n = 2; n <= 100; n++) {
			for (m = 2; m < n / 2; m++) {
				if (n % m == 0)
					continue A;
             // 如果能被整除则变量n肯定不是素数，跳出内层循环
			}

			System.out.print(n + " " + "\t");//输出素数
		}
	}
}
~~~


##查找

###什么是查找

查找指在一个数据元素集合中查找关键字或等于某个给定关键字数据元素的过程，是对数据进行操作或处理时经常使用的操作。

在计算机应用系统中使用查找的地方有很多，比如高考学生成绩管理系统中的高考学生成绩表中查找考生号码等于某个号码的考生成绩，或是从一批图书中找出某一本图书等。

###顺序查找

查找最简单的方法是“顺序查找法”，即一个一个数据查找，看是否是所需的数据。

例如:查找从命令行输入的参数是否在数组中。

~~~java
public class SequenceSearchApp {
	public static void main(String[] args) {
		String[] arr = { "张三", "李四", "王五", "赵六"};
		String temp = args[0];
		
		for (int i = 0; i < arr.length; i++) {
			if (temp.equals(arr[i])) {
		       System.out.println(temp + "在arr集合中");
		       return;
		    }
		}

		System.out.println(temp + "不在arr集合中");
	}
}
~~~

顺序查找效率分析

顺利查找方法实现起来很简单，但是效率低，例如要从$1000$个数据中要查找某一个所需的数据，而该数据恰恰是最后一个，则需要取数据和比较数据$1000$次，对$n$个数据的取数和比较的平均次数为$n/2$次。

###折半查找

- 折半查找法是一种效率较高的查找方法；
- 用折半查找法的前提是：==数据已按一定的规则（升序或降序）排列好。==
- 其基本思路是：先检索居中的一个数据，看它是否为所需的数据，如果不是，则判断要找的数据是在居中数的哪一边，下次就在这个范围内查找。


假如有一组数为：

$8$，$13$，$21$，$28$，$35$，$41$，$52$，$63$，$71$，$76$，$81$，$95$，$101$，$150$，$164$

要找$21$这个数。
为了直观，把这$15$个数画成如图所示的倒立的树形。

![](fig/SearchExample.png)

“树”的根在上面，“树枝”和“树叶”在下面，每一个数据称了一个“结点”。树根结点是15个数中居中的数（$63$），它有两个“子结点”，左边的比它小，右边的比它大，以下逐级都是按这个规律。

可按以下步骤查找：

- 先将要找的数$21$与数列中“树根结点”比较，由于$21<63$，因此，$21$显然在$63$左面的范围内，而且是第$1$个数到第$7$个数之间的一个数（由于$21<63$，所以已知道不可能是第$8$个数）。
- 再找$1$～$7$个数中居中位置的一个数（第$4$个数），即$28$，将$21$与$28$相比，由于$21<28$，因此，所找的数必然在第$1$～$3$个数范围内。
- 再找第$1$～$3$个数的居中位置的一个数$13$（即第$2$个数）,将$21$与$13$相比，由于$21>13$，因此，$21$必然在13的右面。
- 由于$21$下面不再分支，因此下一次就直接找到$21$。
- 以上一共查找了$4$次（即树的深度或树的层次），就找到所需的数。

~~~java
public class BinaraySearchApp {
	public static void main(String[] args) {
		int mid, low, high;
		int[] arr = { 8, 13, 21, 28, 35, 41, 52, 63, 71, 76, 81, 95, 101, 150,164 };
		
		low = 0; // 下界
		high = arr.length - 1; // 上界
		int x = Integer.parseInt(args[0]); // x为要查找的元素

		do {
			mid = (low + high) / 2;
			
			if (x == arr[mid]) {		  	
		  		System.out.println(x + "查找成功，在" + mid + "号位置");
				return;
			} 
			else if (x < arr[mid]) // 如果x小于中间值则在左半段查找
				high = mid - 1;
			else if (x > arr[mid]) // 如果x大于中间值则在右半段查找
				low = mid + 1;
		} while (low <= high);
		
		System.out.println(x + "查找失败");
	}
} 
~~~

如果有n个数，采用折半查找，在其中找任何一个数所需查找次数不超过 $[\log_2 n] + 1$

##排序

###什么是排序？

- 所谓排序是指将一组无序的数据元素调整为一个从小到大或者从大到小排列的有序序列。
- 排序的目的是为了便于查找或为了适应某些查找算法的需要。

排序的算法很多，如果依据各种排序算法的基本处理思想及基本的执行过程来进行分类，大致可分为插入排序法、交换排序法、选择排序法、归并排序法及基数排序法。 


###插入排序法

直接插入排序法的排序原则是：<br>
将一组无序的数字排列成一排，左端第一个数字为已经完成排序的数字，其他数字为未排序的数字。<br>
然后从左到右依次将未排序的数字插入到已排序的数字中。

直接插入排序具体算法描述如下：

- 1）从第一个元素开始，该元素可以认为已经被排序； 
- 2）取出下一个元素，在已经排序的元素序列中从后向前扫描 ；
- 3）如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
- 5）将新元素插入到该位置中；
- 6）重复步骤2；


直接插入排序示例

$49$  $38$  $65$  $97$  $76$  $13$  $27$  $49$

| | |
|:---|:---|
|1|$49$|
|2|$38$ $49$|
|3|$38$ $49$ $65$|
|4|$38$ $49$ $65$ $97$|
|5|$38$ $49$ $65$ $76$ $97$|
|6|$13$ $38$ $49$ $65$ $76$ $97$|
|7|$13$ $27$ $38$ $49$ $65$ $76$ $97$|
|8|$13$ $27$ $38$ $49$ $49$ $65$ $76$ $97$|


程序: 插入排序 

~~~java
public class InsertSortApp {
	public static void main(String[] args) {
		int[] arr = { 49, 38, 65, 97, 76, 13, 27 };
		int i, j, temp;
		int len = arr.length;
		
		for (i = 1; i < len; i++) // 进行len-1趟插入
		{        
			// temp记录本趟要进行插入的元素值
			temp = arr[i];
			j = i - 1;
	       
	       //与已排序的数逐一比较，大于temp时，该数移后
			while ((j >= 0) && (arr[j] > temp)) {
				arr[j + 1] = arr[j];
				j--;
			}
			
			arr[j+1] = temp;	
		}
		
		System.out.println("插入排序的结果是");
		for(i=0;i<len;i++) {
			System.out.print(arr[i]+"  ");
		}
	}
} 

~~~


###冒泡排序法

冒泡排序是交换排序中一种简单的排序方法。<br>
它的基本处理思想是通过对相邻两个数据的比较及其交换来达到排序的目的。


首先将第一个数据与第二个数据进行比较，如果是逆序（即arr[j]>arr[j+1）则交换之，然后比较第二个数据和第三个数据，依此类推，直到第n-1个数据和第n个数据进行过比较为止。<br>
上述过程称为冒泡排序的第一趟处理，第一趟处理的结果使得最大的数据被安置在最后一个元素的位置上。<br>
然后进行第二趟处理，即对前n-1个数据进行上述的处理，第二趟处理的结果是使次大的数据被安置在倒数第二个数据位置上。

一般地，冒泡排序的第i趟是从arr[0]到arr[n-i]依次比较相邻两个元素的关键字，并在逆序时交换相邻的数据，其结果是将这n-i+1个数据中最大的交换到n-i的位置上。<br>
整个排序过程需要进行n-1趟处理，第n-1趟处理使倒数第二的数据安置在第二个数据位置上，这时整个排序过程就已完成。

示例

![](fig/sortsample.png)

程序: 冒泡排序 

~~~java
public class BubbleSortApp {
  public static void main(String[] args) {
	int[] arr = { 51, 38, 49, 27, 62, 5, 16 };
	int i, j, temp, len;
	len = arr.length;
	for (i = len - 1; i > 0; i--) {
		for (j = 0; j < i; j++) {
			if (arr[j] > arr[j + 1]) {
				// 进行数据交换
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	System.out.println("冒泡排序的结果是");
	for (i = 0; i < len; i++) {
		System.out.print(arr[i] + "  ");
	}
}
} 

~~~


###选择排序法

选择排序的基本思想是每一趟（假设是第$i$趟）处理都是从$n-i+1$个数据中选择一个数据最小（或最大）的作为有序序列中的第$i$个数据。

其中最简单的一种称为直接选择排序。

直接选择排序的第一趟处理是从数据序列所有$n$个数据中选择一个最小的数据作为有序序列中的第$1$个元素并将它定位在第一号存储位置，第二趟处理从数据序列的$n-1$个数据中选择一个第二小的元素作为有序序列中的第$2$个元素并将它定位在第二号存储位置，依此类推，当第$n-1$趟处理从数据序列的剩下的$2$个元素中选择一个较小的元素作为有序序列中的最后第$2$个元素并将它定位在倒数第二号存储位置，至此，整个的排序处理过程就已完成。

![](fig/sortsample2.png)

~~~java
public class SelectSortApp {
	public static void main(String[] args) {
		int[] arr = { 51, 38, 49, 27, 62, 5, 16 };
		int i,j,min,temp,len;
		
		len=arr.length;
		
		for(i=0;i<len-1;i++) { //进行len-1趟选择
			min=i; 
			
			for(j=i+1;j<len;j++) {  
				//选择从i到n-1号位置中最小的值的下标
				
				if(arr[min]>arr[j])	{
					min=j;
				}
			} //如果最小值不在i号位置，则交换min与i号位置的值
			
			if(min!=i) {			
				temp=arr[i];
				arr[i]=arr[min];
				arr[min]=temp;
			}  
		}      
		
		System.out.println("选择排序的结果是");
		
		for(i=0;i<len;i++){
			System.out.print(arr[i]+"  ");
		}
	}
}
~~~




##递归

###什么是递归

在数学及程序设计方法学中为递归下的定义是：
==若一个对象部分地包含它自己或用它自己给自己定义，则称这个对象是递归的。==<br>
对于一个方法来说，==若直接或间接地调用它自己，则该方法为递归方法==。

递归是一种算法设计方法，也是计算机程序设计问题中可利用的最有效的解题方法之一。<br>
在程序设计中，递归的解决方案的使用相当普遍，递归的解决方法比非递归的解决方法更精妙、更简洁。
有些问题看起来很复杂，但是使用递归的方法来解决却非常简单。 

求解费波纳契数列—递推法

其基本思想是不断地由已知值推出新值，直至求得解。

~~~java
int fib(int n) {
	int i, x, y, z;
	
	x = 1;	
	y = 1;	
	i = 3;
	
	do {
		z = x + y;
		x = y;
		y = z;
		i++;
	} while (i <= n);
	
	return z;
}
~~~

其基本思想是不断把问题分解成规模较小的同类问题，直至问题足够小能直接求得解为止。 

~~~java
int fib(int n) {
		if (n == 1 || n == 2)
			return 1;
		else
			return fib(n - 1) + fib(n - 2);
	}
~~~

从上述程序设计实例可以看出，递归算法适应于这样一类问题：在对求解的过程中得到的是和原问题性质相同的子问题，这一类问题自然可以用一个递归方法进行描述。

设计递归算法时，通常可以先写出问题求解的递归定义。递归定义由基本项和归纳项两部分组成。基本项描述递归过程的终结状态。所谓终结状态，是指不需要继续递归而可直接求解的状态。归纳项描述了如何实现从当前状态到终结状态的转化。

递归过程的特点是结构清晰、程序简练易读、正确性容易证明，因此是程序设计的有力工具。

